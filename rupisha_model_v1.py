# -*- coding: utf-8 -*-
"""Rupisha_model_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RVJ20JbZhtAJNpnZpml_eeIYD6lDhl2k

**Breast Cancer Detectio using Logistic Regression**
"""

#importing python libraries
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# read csv file
df = pd.read_csv('data.csv')

print(df)

df.head()

# encode data into binary data
df["diagnosis"].value_counts()

"""B --> Benign
M
0 --> Malignant
"""

df['diagnosis'].unique()

df['diagnosis'] = df['diagnosis'].map({'M': 0, 'B': 1})

df.tail()

#number of rows and colums
df.shape

df.info()

# check for missing values
df.isnull().sum()

# statistical measures about the data
df.describe()

# mean values of all the columns for Benign and Malignant
df.groupby('diagnosis').mean()

print(df.columns)

df = df.drop(columns=['Unnamed: 32' , 'id'])
print(df)

# take all the inputs as X and the label column as Y
X = df.drop(columns='diagnosis', axis=1)
Y = df['diagnosis']

print(X)

print(X)

print(Y)

# Splitting the data into training data & Testing data
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

print(X.shape, X_train.shape, X_test.shape)

"""### LogisticRegression"""

from sklearn.linear_model import LogisticRegression

# for training the model using Logistic Regression
model = LogisticRegression()
model.fit(X_train, Y_train)

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

# Assuming X_test and y_test are your test datasets
# and logistic_model is your trained logistic regression model

# Predict probabilities
probs = model.predict_proba(X_test)
# Keep probabilities for the positive outcome only
probs = probs[:, 1]

# Compute ROC curve
fpr, tpr, thresholds = roc_curve(Y_test, probs)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

import matplotlib.pyplot as plt

# Assuming logistic_model is your trained logistic regression model
# and X_train is the training data with feature names as columns
coefficients = model.coef_[0]  # Extract coefficients
feature_names = X_train.columns  # Get feature names

# Create a DataFrame to hold feature names and their corresponding coefficients
coef_df = pd.DataFrame({'Feature': feature_names, 'Coefficient': coefficients})

# Sort the DataFrame based on the absolute values of the coefficients
coef_df = coef_df.sort_values(by='Coefficient', key=abs, ascending=False)

# Plotting the Coefficient Plot
plt.figure(figsize=(10, 6))
plt.barh(coef_df['Feature'], coef_df['Coefficient'], color='skyblue')
plt.xlabel('Coefficient Value')
plt.ylabel('Feature')
plt.title('Coefficient Plot for Logistic Regression Model')
plt.axvline(x=0, color='red', linestyle='--')  # Adds a reference line at coefficient value 0
plt.show()

# Evaluation of model
# accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(Y_train, X_train_prediction)

print('Accuracy on training data: ', training_data_accuracy)

# accuracy on testing data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(Y_test, X_test_prediction)

print('Accuracy on testing data: ', test_data_accuracy)

import csv

def get_numeric_values(row):
    try:
        # Convert the third and fourth values in the row to numeric values
        value1 = float(row[2])
        value2 = float(row[3])
        return [value1, value2]
    except ValueError as e:
        print(f"Error converting values to numeric: {e}")
        return None

def get_row_data(csv_file_path, row_number):
    try:
        with open(csv_file_path, 'r') as file:
            csv_reader = csv.reader(file)

            # Skip headers if present
            headers = next(csv_reader, None)

            # Check if the requested row number is within the valid range
            if row_number <= 0:
                raise ValueError("Row number should be greater than 0.")

            # Iterate through the rows until reaching the desired row
            current_row = 1
            for row in csv_reader:
                if current_row == row_number:
                    return tuple(row[2:])
                current_row += 1

            # If the desired row is not found
            raise ValueError(f"Row number {row_number} exceeds the number of rows in the file.")

    except FileNotFoundError:
        print(f"File not found: {csv_file_path}")
    except Exception as e:
        print(f"An error occurred: {e}")

# Example usage
csv_file_path = 'data.csv'  # Replace with the path to your CSV file
row_number = 20  # Replace with the desired row number

try:
    row_data = get_row_data(csv_file_path, row_number)
    if row_data:
        print(f"Data from row {row_number}: {row_data}")
except ValueError as ve:
    print(ve)

row_data

"""Building a Predictive System"""

#input_data = (13.54,14.36,87.46,566.3,0.09779,0.08129,0.06664,0.04781,0.1885,0.05766,0.2699,0.7886,2.058,23.56,0.008462,0.0146,0.02387,0.01315,0.0198,0.0023,15.11,19.26,99.7,711.2,0.144,0.1773,0.239,0.1288,0.2977,0.07259)

input_data_as_numpy_array = np.array(row_data, dtype=float)

input_data_reshaped = input_data_as_numpy_array.reshape(1, -1)

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0] == 0):
  print('The breast cancer is Malignant')

else:
  print('The breast cancer is Benign')